#!/usr/bin/env bash

# a script to create a H264 derivative of a given input. Make access happen!
# all comments refer to line(s) above unless placed in-line with code or specified otherwise

# load nmaahcmmfunctions into this script
script_path=${0%/*}
. "${script_path}/nmaahcmmfunctions"
[[ -f "${script_path}/nmaahcmmfunctions" ]] || { echo "Missing '${script_path}/nmaahcmmfunctions'. Exiting." ; exit 1 ;};
_setcolors # assigns colors using a function defined in nmaahcmmfunctions
_initialize_make # safe script termination process defined in nmaahcmmfunctions

relativepath="derivative"
suffix="" #suffix is blank here but can be filled in with desired characters for inlcusion in filename
extension="mp4"

## USAGE

usage(){
    echo
    echo "$(basename "${0}")"
    echo "This application will create a high quality h264 file (suitable for uploading to YouTube). It takes one or more .mov video files, or packages containing .mov files, as input."
    echo "The script expects that any packages will hold only one .mov file and will only create a derivative for the first .mov file it finds within the package."
    echo "The derivative will be named according to the input (i.e. it will have the same name as the master file or package)."
    echo "Usage: $(basename ${0}) fileorpackage1 [ fileorpackage2 ...]"
    echo
    exit
}
[ "${#}" = 0 ] && usage # if the command is run with no arguments then usage is called
# getopts loop
OPTIND=1
while getopts ":h" OPT; do
    case "${OPT}" in
        h) usage ;;  # if the operator runs "[scriptname] -h" then the usage text above will display in the terminal
        *) echo "Invalid option -${OPTARG}" ; usage ;; # if the operator tries to use an option other than the ones listed above, the usage text will display in the terminal
    esac
done
shift $(( ${OPTIND} - 1 ))

## SCRIPT ACTIONS

while [ "${*}" != "" ] ; do

    input="${1}" #set $input as the first argument sent to script
    if [[ -f "${input}" ]] ; then #if input is a file, set output_dir to input name with extension stripped plus relativepath
        output_dir="${input%.*}/${relativepath}"
    elif [[ -d "${input}" ]]; then #if input is a directory, set output_dir to input name plus relativepath
        output_dir="${input}/${relativepath}"
    fi
    
    mediaid="${input##*/}" #set $mediaid to basename of $input
    mediaid="${mediaid%.*}" #set $mediaid to $mediaid with extension stripped
    output="${output_dir}/${mediaid%.*}${suffix}.${extension}" #set $output
    if [ -s "${output}" ] ; then #check to see if $output exists
        printf "%sWARNING ${output} already exists, skipping transcode of %s.%s%s\n" "${bired}" "${input}" "${color_off}" "${biwhite}"
        printf "Moving to next file if present...\n${color_off}"
    else
        printf "%smediaid is: %s%s\n" "${color_off}" "${biwhite}" "${mediaid}"
        printf "%sThe output directory is: %s%s\n" "${color_off}" "${biwhite}" "${output_dir}"
        printf "%soutput is: %s%s\n" "${color_off}" "${biwhite}" "${output}"

        echo
cat <<-EOF
    A CRF value needs specified.
    The range of the quantizer scale is 0-51, where 0 is lossless, 23 is default, and 51 is worst possible.
    A lower value is a higher quality and a subjectively useful range is 18-28.
    Consider 18 to be visually lossless or nearly so: it should look the same or nearly the same as the input,
    but it is not technically lossless.
    The range is exponential, so increasing the CRF value +6 is roughly half the bitrate, while -6 is roughly twice the bitrate.
    General usage is to choose the highest CRF value that still provides an acceptable quality.
    If the output looks good, then try a higher value. If it looks bad then choose a lower value.
EOF
        echo
        printf "%sPlease enter a CRF value:%s\n" "${color_off}" "${biwhite}"
        read -r crfvalue
        echo
cat <<-EOF
    A preset encoding speed needs specified.
    A preset is a collection of options that will provide a certain encoding speed to compression ratio.
    A slower preset will provide better compression (compression is quality per filesize).
    This means that, for example, if you target a certain file size or constant bit rate,
    you will achieve better quality with a slower preset.
    Similarly, for constant quality encoding, you will simply save bitrate by choosing a slower preset.
    The general guideline is to use the slowest preset that you have patience for.
    Current presets in descending order of speed are:
EOF
        printf "%sultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow\n" "${bired}"
        #printf "%s" "${biwhite}"
        echo
        printf "%sPlease enter a preset speed:%s\n" "${color_off}" "${biwhite}"
        read -r presetspeed
        echo
cat <<-EOF
    The maxrate speed is the maximum bitrate at which your video will be encoded. It is written in kbps.
    A good maxrate for YouTube-type delivery is 8000.
EOF
        echo
        printf "%sPlease enter a maxrate speed:%s\n" "${color_off}" "${biwhite}"
        read -r maxrate
        
        printf "\n%smaking .mp4 derivative of %s%s%s\n" "${color_off}" "${biwhite}" "${mediaid}" "${color_off}" #have script say what is about to do
        mkdir -p "${output_dir}"

        # run ffmpeg command on $INPUT and send output to a file at location $OUTPUT
        if [[ -f "${input}" ]]; then # if the input is a file, run the ffmpeg command on that file
            # -vf scale=-2:1484
            ffmpeg -n -vsync 0 -nostdin -v info -hide_banner -stats -i "${input}" -movflags faststart -c:v libx264 -vf "yadif,format=yuv420p" -crf "${crfvalue}" -preset "${presetspeed}" -maxrate "${maxrate}"k -bufsize 1835k -c:a aac -strict -2 -b:a 384k -f mp4 "${output}"
        elif [[ -d "${input}" ]]; then  # if the input is a directory, find an .mov file within the directory and run the ffmpeg command on that file
            ##### This command currently only works for the first file the "find" command locates within a directory
            ffmpeg -n -vsync 0 -nostdin -v info -hide_banner -stats -i "${input}"/*.mov -movflags faststart -pix_fmt yuv420p -c:v libx264 -crf "${crfvalue}" -preset "${presetspeed}" -maxrate "${maxrate}"k -bufsize 1835k -c:a aac -strict -2 -b:a 384k -f mp4 "${output}"
        fi
        printf "\nSuccess! Derivative ${biwhite}$(basename ${output})${color_off} created.\n\n"
    fi
    shift
done

printf "${biwhite}makeH264 process complete.${color_off}\n"

exit "$?"
