#!/usr/bin/env bash

# load nmaahcmmfunctions into this script
script_path=${0%/*}
. "${script_path}/nmaahcmmfunctions"
[[ -f "${script_path}/nmaahcmmfunctions" ]] || { echo "Missing '${script_path}/nmaahcmmfunctions'. Exiting." ; exit 1 ;};
_setcolors # assigns colors using a function defined in nmaahcmmfunctions
_initialize_make # safe script termination process defined in nmaahcmmfunctions

RELATIVEPATH="access"
SUFFIX="" #SUFFIX is blank here but can be filled in with desired characters for inlcusion in filename
EXTENSION="mp4"

### USAGE

usage(){
    echo
    echo "$(basename "${0}")"
    echo "This application will create a high quality h264 file (suitable for uploading to YouTube). It takes a video file or package as input."
    echo "The script expects that any packages will hold only one .mov file and will only create a derivative for the first .mov file it finds within the package."
    echo "The derivative will be named according to the input (i.e. it will have the same name as the master file or package)."
    echo "Usage: $(basename ${0}) [ -d /path/to/deliver/to/ ] fileorpackage1 [ fileorpackage2 ...]"
    echo
    exit
}
[ "${#}" = 0 ] && usage # if the the command is run with no arguments then usage is called

#command-line options to set mediaid and original variables
OPTIND=1
while getopts ":o:d:" OPT ; do
    case "${OPT}" in
        o)
            OUTPUTDIR_FORCED="${OPTARG}" && _check_outputdir_forced
            echo outputdirectory is "${OUTPUTDIR_FORCED}"
            ;;
        d)
            DELIVERDIR="${OPTARG}" && _check_deliverdir
            ;;
        h)
            usage # if the operator runs "[scriptname] -h" then the usage text above will display in the terminal
            ;;
        \?)
            echo "Invalid option: -$OPTARG" >&2
            exit 1
            ;;
        :)
            echo "Option -$OPTARG requires an argument." >&2
            exit 1
            ;;
    esac
done
shift $(( ${OPTIND} - 1 ))

### FUNCTIONS

_check_outputdir_forced(){
    if [ ! -d "${OUTPUTDIR_FORCED}" ] ; then
        printf "\n${bired}" "The directory, ${OUTPUTDIR_FORCED}, does not exist. Can not write the output of $(basename "${0}").${color_off}\n"
       #_writeerrorlog "_check_outputdir_forced" "The specified directory does not exist, and the output could not be delivered."
    fi
}

while [ "${*}" != "" ] ; do

    #set $INPUT as the first arugment sent to script
    INPUT="${1}"
    #shift
    if [[ -z "${OUTPUTDIR_FORCED}" ]]; then
        if [[ -f "${INPUT}" ]]; then
            OUTPUT_DIR="${INPUT%%.*}/${RELATIVEPATH}"
        fi
        if [[ -d "${INPUT}" ]]; then
            OUTPUT_DIR="${INPUT}/${RELATIVEPATH}"
        fi
    else
        OUTPUT_DIR="${OUTPUTDIR_FORCED}"
    fi
    printf "output directory is: ${biwhite}${OUTPUT_DIR}${color_off}\n"
    PARENTDIR="$(dirname "${OUTPUT_DIR}")"
    printf "parent directory is: ${biwhite}${PARENTDIR}${color_off}\n"

    #set $MEDIAID to basename of $INPUT with extension stripped
    MEDIAID=$(basename "${INPUT}" | cut -d. -f1)
    printf "MEDIAID is: ${biwhite}$(basename "${INPUT}" | cut -d. -f1)${color_off}\n"

    #set $OUTPUT
    OUTPUT="${OUTPUT_DIR}/${MEDIAID%.*}${SUFFIX}.${EXTENSION}"
    printf "OUTPUT is: ${biwhite}${OUTPUT}${color_off}\n"

    #check to see if $OUTPUT exists
    if [[ -s "${OUTPUT}" ]] ; then
        printf "${bired}WARNING ${OUTPUT} already exists, skipping transcode\n"
        printf "Moving to next file if present...\n${color_off}"
    else
        echo
cat <<-EOF
    A CRF value needs specified.
    The range of the quantizer scale is 0-51: where 0 is lossless, 23 is default, and 51 is worst possible.
    A lower value is a higher quality and a subjectively sane range is 18-28.
    Consider 18 to be visually lossless or nearly so: it should look the same or nearly the same as the input but it is not technically lossless.
EOF
        echo
        printf "${biwhite}Please enter a CRF value: ${color_off}"
        read CRFVALUE
        echo
cat <<-EOF
    A preset encoding speed needs specified.
    A preset is a collection of options that will provide a certain encoding speed to compression ratio.
    A slower preset will provide better compression (compression is quality per filesize).
    This means that, for example, if you target a certain file size or constant bit rate,
    you will achieve better quality with a slower preset.
    Similarly, for constant quality encoding, you will simply save bitrate by choosing a slower preset.
    The general guideline is to use the slowest preset that you have patience for.
    Current presets in descending order of speed are:
EOF
    printf "${bired}ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow${color_off}"
cat <<-EOF
    The range is exponential, so increasing the CRF value +6 is roughly half the bitrate while -6 is roughly twice the bitrate.
    General usage is to choose the highest CRF value that still provides an acceptable quality.
    If the output looks good, then try a higher value and if it looks bad then choose a lower value.
EOF
        echo
        printf "${biwhite}Please enter a preset speed: ${color_off}"
        read PRESETSPEED

        #have script say what is about to do
        printf "\n${biwhite}making .mp4 derivative of $(basename ${MEDIAID})${color_off}\n"
        mkdir -p "${OUTPUT_DIR}"
        #mv -v "${INPUT}" "${PARENTDIR}"

        #run ffmpeg command on $INPUT and set output to $OUTPUT
        if [[ -f "${INPUT}" ]]; then
            #statements
            ffmpeg -vsync 0 -nostdin -v info -hide_banner -stats -i "${INPUT}" -movflags faststart -pix_fmt yuv420p -c:v libx264 -crf "${CRFVALUE}" -preset "${PRESETSPEED}" -c:a aac -strict -2 -b:a 384k -f mp4 "${OUTPUT}"
            #mv -v -n "${INPUT}" "${PARENTDIR}"
        elif [[ -d "${INPUT}" ]]; then
            #statements
            # this command currently only works for the first file the "find" command locates within a directory
            ffmpeg -vsync 0 -nostdin -v info -hide_banner -stats -i "${INPUT}"/objects/*.mov -movflags faststart -pix_fmt yuv420p -c:v libx264 -crf "${CRFVALUE}" -preset "${PRESETSPEED}" -c:a aac -strict -2 -b:a 384k -f mp4 "${OUTPUT}"
        fi

        #rename file to indcate derivative
        cd "${OUTPUT_DIR}"
        if [[ -n $(find . -type f -name "*PM*.mp4" ) ]]; then # find all mp4s with "PM" in the name within the output directory; the "if" executes if the find statement executes to non-empty ("-n")
            rename 's/PM/DER_02/' *.mp4 && printf "\n${biwhite}Updated derivative filename to reflect current name : PM to DER_02${color_off}\n"
        fi
        if [[ -n $(find . -type f -name "*DER_01*.mp4" ) ]]; then # find all mp4s with "DER_01" in the name within the output directory; the "if" executes if the find statement executes to non-empty ("-n")
            rename 's/DER_01/DER_03/' *.mp4 && printf "\n${biwhite}Updated derivative filename to reflect current name conventions: DER_01 to DER_03${color_off}\n"
        fi
        cd ~

        printf "\nSuccess! Derivative ${biwhite}$(basename ${OUTPUT})${color_off} created.\n\n"
    fi
    shift
done

printf "${biwhite}makeDer process complete.${color_off}\n"
